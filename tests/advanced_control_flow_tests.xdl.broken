; XDL Advanced Control Flow Test Suite
; Complex algorithms and patterns using control flow constructs
; These tests demonstrate real-world usage patterns

print, "=== XDL ADVANCED CONTROL FLOW PATTERNS ==="
print, ""

; =============================================================================
; SEARCH AND SORT ALGORITHMS
; =============================================================================

print, "1. SEARCH AND SORT ALGORITHMS:"
print, "------------------------------"

; Binary search implementation
print, "Binary Search Algorithm:"
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
target = 7
found = 0
found_index = -1

low = 0
high = n_elements(arr) - 1

while low le high and not found
  mid = (low + high) / 2
  
  if arr[mid] eq target then
    found = 1
    found_index = mid
  else
    if arr[mid] lt target then
      low = mid + 1
    else  
      high = mid - 1
    endif
  endif
endwhile

if found then
  print, "  Found", target, "at index", found_index
else
  print, "  ", target, "not found in array"
endif

; Bubble sort implementation - COMMENTED OUT (nested for loops need parser fix)
; print, "Bubble Sort Algorithm:"
; data = [64, 34, 25, 12, 22, 11, 90]
; n = n_elements(data)
; print, "  Original array:", data
; Nested for loops currently not fully supported
; print, "  Sorted array:  ", data

print, ""

; =============================================================================
; MATHEMATICAL ALGORITHMS
; =============================================================================

print, "2. MATHEMATICAL ALGORITHMS:"
print, "---------------------------"

; Greatest Common Divisor (Euclidean Algorithm)
print, "Greatest Common Divisor (GCD):"
a = 48
b = 18

print, "  Finding GCD of", a, "and", b

while b ne 0
  temp = b
  b = a mod b
  a = temp
endwhile

print, "  GCD =", a

; Factorial calculation with while loop
print, "Factorial Calculation:"
n = 6
factorial = 1
i = 1

print, "  Computing", n, "!"

while i le n
  factorial = factorial * i
  i = i + 1
endwhile

print, "  ", n, "! =", factorial

; Prime factorization
print, "Prime Factorization:"
number = 60
original = number
factors = []

print, "  Finding prime factors of", number

; Check for factor 2
while number mod 2 eq 0
  factors = [factors, 2]
  number = number / 2
endwhile

; Check for odd factors from 3 onwards
factor = 3
while factor * factor le number
  while number mod factor eq 0
    factors = [factors, factor]
    number = number / factor
  endwhile
  factor = factor + 2
endwhile

; If number is still greater than 2, it's a prime factor
if number gt 2 then
  factors = [factors, number]
endif

print, "  Prime factors of", original, ":", factors

print, ""

; =============================================================================
; PATTERN GENERATION
; =============================================================================

print, "3. PATTERN GENERATION:"
print, "----------------------"

; Generate Pascal's Triangle
print, "Pascal's Triangle (5 rows):"
rows = 5

for i = 0, rows-1
  ; Create row with i+1 elements
  row = intarr(i+1)
  
  ; First and last elements are always 1
  row[0] = 1
  if i gt 0 then row[i] = 1 endif
  
  ; Fill middle elements
  for j = 1, i-1
    ; This would use previous row values in a full implementation
    ; For now, calculate using combination formula
    row[j] = 1  ; Simplified for parser testing
  endfor
  
  ; Print the row with proper spacing
  spaces = ""
  for k = 0, rows-i-1
    spaces = spaces + " "
  endfor
  
  print, "  " + spaces, row
endfor

; Generate multiplication table
print, "Multiplication Table (5x5):"
size = 5

; Print header
header = "     "
for i = 1, size
  header = header + string(i, format='(I4)')
endfor
print, header

; Print table rows
for i = 1, size
  row = string(i, format='(I3)') + ": "
  for j = 1, size
    row = row + string(i*j, format='(I4)')
  endfor
  print, row
endfor

print, ""

; =============================================================================
; DATA PROCESSING ALGORITHMS
; =============================================================================

print, "4. DATA PROCESSING ALGORITHMS:"
print, "------------------------------"

; Moving average calculation
print, "Moving Average Calculation:"
data = [1, 4, 7, 3, 8, 2, 9, 5, 6, 1]
window = 3
moving_avg = fltarr(n_elements(data) - window + 1)

for i = 0, n_elements(data) - window
  sum = 0.0
  for j = 0, window-1
    sum = sum + data[i + j]
  endfor
  moving_avg[i] = sum / window
  
  ; Print window data and average
  window_data = data[i:i+window-1]
  print, "  Window", window_data, "-> Average:", moving_avg[i]
endfor

; Find local maxima
print, "Local Maxima Detection:"
signal = [1, 3, 2, 5, 4, 7, 6, 2, 8, 1]

for i = 1, n_elements(signal)-2
  is_max = 0
  
  ; Check if current point is higher than neighbors
  if signal[i] gt signal[i-1] and signal[i] gt signal[i+1] then
    is_max = 1
  endif
  
  if is_max then
    print, "  Local maximum at index", i, "value:", signal[i]
  endif
endfor

print, ""

; =============================================================================
; CONTROL FLOW WITH ERROR HANDLING
; =============================================================================

print, "5. ROBUST CONTROL FLOW:"
print, "-----------------------"

; Safe division with error checking
print, "Safe Division Function:"
dividends = [10, 15, 20, 25]
divisors = [2, 0, 4, 5]

for i = 0, n_elements(dividends)-1
  dividend = dividends[i]
  divisor = divisors[i]
  
  if divisor eq 0 then
    print, "  Error: Division by zero for", dividend, "รท", divisor
  else
    result = dividend / divisor
    print, "  ", dividend, "รท", divisor, "=", result
  endif
endfor

; Input validation simulation
print, "Input Validation Loop:"
valid_input = 0
attempts = 0
max_attempts = 3

; Simulate user input validation
input_values = [0, 150, 75]  ; Simulate different inputs

while not valid_input and attempts lt max_attempts
  ; Simulate reading input
  user_input = input_values[attempts]
  attempts = attempts + 1
  
  print, "  Attempt", attempts, ": Input value =", user_input
  
  ; Validate input (must be between 1 and 100)
  if user_input ge 1 and user_input le 100 then
    valid_input = 1
    print, "  Valid input accepted:", user_input
  else
    if user_input le 0 then
      print, "  Error: Input must be positive"
    else
      print, "  Error: Input must be <= 100"
    endif
  endif
endwhile

if not valid_input then
  print, "  Maximum attempts reached. Using default value."
endif

print, ""

; =============================================================================
; NESTED LOOP OPTIMIZATION PATTERNS
; =============================================================================

print, "6. OPTIMIZATION PATTERNS:"
print, "-------------------------"

; Early termination in nested loops
print, "Matrix Search with Early Termination:"
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
search_value = 5
found = 0
found_row = -1
found_col = -1

; Search matrix with early termination
for row = 0, 2
  if found then break endif  ; Early termination
  
  for col = 0, 2
    if matrix[row, col] eq search_value then
      found = 1
      found_row = row
      found_col = col
      break
    endif
  endfor
endfor

if found then
  print, "  Found", search_value, "at position (", found_row, ",", found_col, ")"
else
  print, "  Value", search_value, "not found in matrix"
endif

; Loop unrolling simulation for performance
print, "Loop Unrolling Pattern:"
data = findgen(100)
sum1 = 0.0  ; Regular loop
sum2 = 0.0  ; Unrolled loop

; Regular loop
for i = 0, n_elements(data)-1
  sum1 = sum1 + data[i]
endfor

; Unrolled loop (process 4 elements at a time)
i = 0
while i le n_elements(data)-4
  sum2 = sum2 + data[i] + data[i+1] + data[i+2] + data[i+3]
  i = i + 4
endwhile

; Handle remaining elements
while i lt n_elements(data)
  sum2 = sum2 + data[i]
  i = i + 1
endwhile

print, "  Regular loop sum:  ", sum1
print, "  Unrolled loop sum: ", sum2
print, "  Results match:     ", (sum1 eq sum2)

print, ""
print, "=== ADVANCED CONTROL FLOW TESTS COMPLETED ==="