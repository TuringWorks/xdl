; ================================================================
; Geophysical Data Visualization Workflow (Simplified)
; ================================================================
; Demonstrates:
; - Synthetic seismic data generation
; - Geological layer modeling
; - Fault detection and visualization
; - Cross-section extraction
; - Amplitude and phase analysis
; - Horizon tracking
; ================================================================

PRINT, '=================================================='
PRINT, 'Geophysical Data Visualization Workflow'
PRINT, '=================================================='
PRINT, ''

; ================================================================
; STEP 1: Define Survey Parameters
; ================================================================
PRINT, '> Step 1: Setting up survey parameters...'
PRINT, ''

; 3D seismic cube dimensions (reduced for faster computation)
nx = 64  ; Inline direction
ny = 64  ; Crossline direction
nz = 32  ; Time/depth direction

PRINT, '  Survey dimensions: ', nx, ' x ', ny, ' x ', nz
PRINT, '  Inline traces: ', nx
PRINT, '  Crossline traces: ', ny
PRINT, '  Time samples: ', nz

; Spatial sampling
dx = 25.0  ; meters
dy = 25.0  ; meters
dz = 4.0   ; milliseconds (two-way time)

PRINT, '  Inline spacing: ', dx, ' m'
PRINT, '  Crossline spacing: ', dy, ' m'
PRINT, '  Time sampling: ', dz, ' ms'
PRINT, ''

; ================================================================
; STEP 2: Create Geological Layer Model
; ================================================================
PRINT, '> Step 2: Creating geological layer model...'
PRINT, ''

; Initialize seismic cube
seismic = FLTARR(nx, ny, nz)

; Define geological layers with different acoustic properties
PRINT, '  Defining stratigraphic layers...'

; Layer 1: Shallow sediments (0-30ms)
; Layer 2: Sandstone reservoir (30-50ms) with anticline
; Layer 3: Shale cap rock (50-70ms) with fault
; Layer 4: Deeper formations (70-128ms)

; Create layer interfaces
x_grid = FINDGEN(nx)
y_grid = FINDGEN(ny)

; Interface 1: Gradual dip from west to east
interface1_depth = FLTARR(nx)
FOR i = 0, nx-1 DO BEGIN
    interface1_depth[i] = 30.0 + 0.05 * i
ENDFOR
PRINT, '    Layer 1: Shallow sediments (0-30ms)'

; Interface 2: Anticline structure (potential reservoir)
interface2_depth = FLTARR(nx, ny)
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        ; Anticline: dome structure
        dx_center = (i - nx/2.0) / (nx/4.0)
        dy_center = (j - ny/2.0) / (ny/4.0)
        r2 = dx_center * dx_center + dy_center * dy_center
        uplift = 15.0 * EXP(-r2 / 2.0)  ; Gaussian dome
        interface2_depth[i,j] = 50.0 - uplift + 0.05 * i
    ENDFOR
ENDFOR
PRINT, '    Layer 2: Sandstone reservoir with anticline (30-50ms)'

; Interface 3: Faulted horizon
interface3_depth = FLTARR(nx, ny)
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        base_depth = 70.0 + 0.03 * i

        ; Add fault: vertical offset at x = nx/2
        fault_center = nx / 2.0
        fault_width = 10.0
        dist_from_fault = i - fault_center
        IF dist_from_fault LT 0.0 THEN dist_from_fault = -dist_from_fault

        ; Footwall (upthrown side) - default
        interface3_depth[i,j] = base_depth

        ; Hanging wall (downthrown side) - add fault offset
        IF i GT fault_center THEN BEGIN
            fault_offset = 20.0 * EXP(-dist_from_fault / fault_width)
            interface3_depth[i,j] = base_depth + fault_offset
        END
    ENDFOR
ENDFOR
PRINT, '    Layer 3: Faulted shale cap (50-70ms with fault)'
PRINT, '    Layer 4: Deeper formations (70-128ms)'
PRINT, ''

; ================================================================
; STEP 3: Generate Synthetic Seismic Data
; ================================================================
PRINT, '> Step 3: Generating synthetic seismic data...'
PRINT, ''

; Initialize random seed for noise
seed = 42.0

; Generate seismic amplitudes based on layer contrasts
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        FOR k = 0, nz-1 DO BEGIN
            t = k * dz  ; Time in ms

            ; Base amplitude (background noise)
            ; Simple pseudo-random using sin function
            noise_factor = SIN(i * 1.23 + j * 4.56 + k * 7.89 + seed)
            amp = noise_factor * 0.1

            ; Layer 1 reflection (shallow)
            t1 = interface1_depth[i]
            dt1 = t - t1
            IF dt1 LT 0.0 THEN dt1 = -dt1
            IF dt1 LT 3.0 THEN BEGIN
                amp = amp + 0.5 * EXP(-((t - t1) / 1.5) * ((t - t1) / 1.5))
            END

            ; Layer 2 reflection (anticline)
            t2 = interface2_depth[i,j]
            dt2 = t - t2
            IF dt2 LT 0.0 THEN dt2 = -dt2
            IF dt2 LT 3.0 THEN BEGIN
                amp = amp + 0.8 * EXP(-((t - t2) / 1.5) * ((t - t2) / 1.5))  ; Strong reflection
            END

            ; Layer 3 reflection (fault)
            t3 = interface3_depth[i,j]
            dt3 = t - t3
            IF dt3 LT 0.0 THEN dt3 = -dt3
            IF dt3 LT 3.0 THEN BEGIN
                amp = amp + 0.6 * EXP(-((t - t3) / 1.5) * ((t - t3) / 1.5))
            END

            seismic[i,j,k] = amp
        ENDFOR
    ENDFOR
ENDFOR

; Find min/max of seismic cube
seismic_min = MIN(seismic)
seismic_max = MAX(seismic)

PRINT, '  Seismic cube generated'
PRINT, '    Amplitude range: [', seismic_min, ', ', seismic_max, ']'
PRINT, ''

; ================================================================
; STEP 4: Extract Inline Section
; ================================================================
PRINT, '> Step 4: Extracting inline section...'
PRINT, ''

; Extract section at middle crossline
inline_idx = nx / 2
inline_section = FLTARR(ny, nz)
FOR j = 0, ny-1 DO BEGIN
    FOR k = 0, nz-1 DO BEGIN
        inline_section[j,k] = seismic[inline_idx, j, k]
    ENDFOR
ENDFOR

; Find min/max of inline section
inline_min = MIN(inline_section)
inline_max = MAX(inline_section)

PRINT, '  Inline section extracted at x = ', inline_idx
PRINT, '    Section dimensions: ', ny, ' x ', nz
PRINT, '    Amplitude range: [', inline_min, ', ', inline_max, ']'
PRINT, ''

; ================================================================
; STEP 5: Extract Crossline Section
; ================================================================
PRINT, '> Step 5: Extracting crossline section...'
PRINT, ''

; Extract section through anticline center
crossline_idx = ny / 2
crossline_section = FLTARR(nx, nz)
FOR i = 0, nx-1 DO BEGIN
    FOR k = 0, nz-1 DO BEGIN
        crossline_section[i,k] = seismic[i, crossline_idx, k]
    ENDFOR
ENDFOR

; Find min/max of crossline section
crossline_min = MIN(crossline_section)
crossline_max = MAX(crossline_section)

PRINT, '  Crossline section extracted at y = ', crossline_idx
PRINT, '    Section dimensions: ', nx, ' x ', nz
PRINT, '    Amplitude range: [', crossline_min, ', ', crossline_max, ']'
PRINT, ''

; ================================================================
; STEP 6: Extract Time Slice (Horizon)
; ================================================================
PRINT, '> Step 6: Extracting time slice at reservoir level...'
PRINT, ''

; Time slice at anticline level (approximately t=40ms)
t_slice_idx = 40 / dz  ; Convert ms to sample index
time_slice = FLTARR(nx, ny)
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        time_slice[i,j] = seismic[i, j, t_slice_idx]
    ENDFOR
ENDFOR

; Find min/max of time slice
slice_min = MIN(time_slice)
slice_max = MAX(time_slice)

PRINT, '  Time slice extracted at t = ', t_slice_idx * dz, ' ms'
PRINT, '    Amplitude range: [', slice_min, ', ', slice_max, ']'
PRINT, ''

; ================================================================
; STEP 7: Compute Seismic Attributes
; ================================================================
PRINT, '> Step 7: Computing seismic attributes...'
PRINT, ''

; Instantaneous amplitude (envelope) - using absolute value
inst_amp = FLTARR(nx, ny, nz)
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        FOR k = 0, nz-1 DO BEGIN
            val = seismic[i,j,k]
            IF val LT 0.0 THEN val = -val
            inst_amp[i,j,k] = val
        ENDFOR
    ENDFOR
ENDFOR
PRINT, '  Instantaneous amplitude computed'

; Vertical gradient (structural discontinuities)
gradient_z = FLTARR(nx, ny, nz-1)
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        FOR k = 0, nz-2 DO BEGIN
            diff = seismic[i, j, k+1] - seismic[i, j, k]
            IF diff LT 0.0 THEN diff = -diff
            gradient_z[i, j, k] = diff
        ENDFOR
    ENDFOR
ENDFOR
PRINT, '  Vertical gradient computed'

; Horizontal gradient (fault detection)
gradient_x = FLTARR(nx-1, ny, nz)
FOR i = 0, nx-2 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        FOR k = 0, nz-1 DO BEGIN
            diff = seismic[i+1, j, k] - seismic[i, j, k]
            IF diff LT 0.0 THEN diff = -diff
            gradient_x[i, j, k] = diff
        ENDFOR
    ENDFOR
ENDFOR
PRINT, '  Horizontal gradient computed (fault indicator)'
PRINT, ''

; ================================================================
; STEP 8: Fault Detection via Gradient Analysis
; ================================================================
PRINT, '> Step 8: Detecting fault via gradient analysis...'
PRINT, ''

; Sum gradient along time axis to create fault probability map
fault_prob = FLTARR(nx-1, ny)
depth_start = 40 / dz
depth_end = 90 / dz
IF depth_end GT nz-1 THEN depth_end = nz-1

FOR i = 0, nx-2 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        ; Sum high gradients in depth window around fault
        sum_val = 0.0
        FOR k = depth_start, depth_end DO BEGIN
            sum_val = sum_val + gradient_x[i, j, k]
        ENDFOR
        fault_prob[i,j] = sum_val
    ENDFOR
ENDFOR

; Find max fault probability
max_fault_prob = fault_prob[0,0]
FOR i = 0, nx-2 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        IF fault_prob[i,j] GT max_fault_prob THEN max_fault_prob = fault_prob[i,j]
    ENDFOR
ENDFOR

PRINT, '  Fault probability map computed'
PRINT, '    Max fault probability: ', max_fault_prob
PRINT, ''

; ================================================================
; STEP 9: Horizon Tracking (Auto-picking)
; ================================================================
PRINT, '> Step 9: Automatic horizon tracking...'
PRINT, ''

; Track anticline horizon (interface 2)
horizon_picks = FLTARR(nx, ny)

search_start = 20 / dz
search_end = 60 / dz
IF search_end GT nz-1 THEN search_end = nz-1

FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        ; Search for maximum amplitude in window around expected depth
        max_amp = -1e10
        max_idx = search_start

        FOR k = search_start, search_end DO BEGIN
            val = seismic[i,j,k]
            IF val LT 0.0 THEN val = -val
            IF val GT max_amp THEN BEGIN
                max_amp = val
                max_idx = k
            END
        ENDFOR

        horizon_picks[i,j] = max_idx * dz
    ENDFOR
ENDFOR

; Find min/max of horizon picks
horizon_min = MIN(horizon_picks)
horizon_max = MAX(horizon_picks)

PRINT, '  Horizon auto-picked'
PRINT, '    Horizon depth range: [', horizon_min, ', ', horizon_max, '] ms'
PRINT, ''

; ================================================================
; STEP 10: Structural Interpretation Summary
; ================================================================
PRINT, '> Step 10: Structural interpretation summary...'
PRINT, ''

; Compute anticline statistics
sum_depth = 0.0
count_depth = 0.0
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        sum_depth = sum_depth + horizon_picks[i,j]
        count_depth = count_depth + 1.0
    ENDFOR
ENDFOR
mean_depth = sum_depth / count_depth

; Compute closure area
closure_count = 0.0
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        IF horizon_picks[i,j] LT mean_depth THEN BEGIN
            closure_count = closure_count + 1.0
        END
    ENDFOR
ENDFOR
closure_area = closure_count * dx * dy / 1e6  ; km²

PRINT, '  Anticline Structure:'
PRINT, '    Mean horizon depth: ', mean_depth, ' ms'
PRINT, '    Peak depth: ', horizon_min, ' ms'
PRINT, '    Structural relief: ', mean_depth - horizon_min, ' ms'
PRINT, '    Closure area: ', closure_area, ' km²'
PRINT, ''

; Fault characterization - reuse max_fault_prob from earlier
max_fault = max_fault_prob
fault_i = 0
fault_j = 0
FOR i = 0, nx-2 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        IF fault_prob[i,j] EQ max_fault THEN BEGIN
            fault_i = i
            fault_j = j
        END
    ENDFOR
ENDFOR

PRINT, '  Fault Characteristics:'
PRINT, '    Fault location: Inline ~ ', fault_i * dx, ' m'
PRINT, '    Fault strike: approximately N-S'
PRINT, '    Throw: ~20ms vertical offset'
PRINT, '    Type: Normal fault (extensional)'
PRINT, ''

; ================================================================
; STEP 11: Amplitude Analysis
; ================================================================
PRINT, '> Step 11: Simplified amplitude analysis...'
PRINT, ''

; Extract amplitude along anticline crest
crest_i = nx / 2
crest_j = ny / 2

; Find reservoir reflection
reservoir_sample = 40 / dz
IF reservoir_sample GT nz-1 THEN reservoir_sample = nz-1
reservoir_amp = seismic[crest_i, crest_j, reservoir_sample]

PRINT, '  Reservoir Reflection:'
PRINT, '    Location: (', crest_i * dx, ', ', crest_j * dy, ') m'
PRINT, '    Time: ', reservoir_sample * dz, ' ms'
PRINT, '    Amplitude: ', reservoir_amp

abs_amp = reservoir_amp
IF abs_amp LT 0.0 THEN abs_amp = -abs_amp

IF abs_amp GT 0.5 THEN BEGIN
    PRINT, '    Interpretation: Strong reflection - possible hydrocarbon indicator'
END
IF abs_amp LE 0.5 THEN BEGIN
    PRINT, '    Interpretation: Moderate reflection - brine-filled'
END
PRINT, ''

; ================================================================
; STEP 12: Statistics and Data Quality
; ================================================================
PRINT, '> Step 12: Data quality assessment...'
PRINT, ''

; Calculate statistics
sum_amp = 0.0
count_amp = 0.0
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        FOR k = 0, nz-1 DO BEGIN
            sum_amp = sum_amp + seismic[i,j,k]
            count_amp = count_amp + 1.0
        ENDFOR
    ENDFOR
ENDFOR
mean_amp = sum_amp / count_amp

; Calculate standard deviation
sum_sq_diff = 0.0
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        FOR k = 0, nz-1 DO BEGIN
            diff = seismic[i,j,k] - mean_amp
            sum_sq_diff = sum_sq_diff + diff * diff
        ENDFOR
    ENDFOR
ENDFOR
stddev_amp = SQRT(sum_sq_diff / count_amp)

; Calculate RMS
sum_sq = 0.0
FOR i = 0, nx-1 DO BEGIN
    FOR j = 0, ny-1 DO BEGIN
        FOR k = 0, nz-1 DO BEGIN
            val = seismic[i,j,k]
            sum_sq = sum_sq + val * val
        ENDFOR
    ENDFOR
ENDFOR
rms_amp = SQRT(sum_sq / count_amp)

; Use seismic_max from earlier (already computed)
max_abs = seismic_max
IF max_abs LT 0.0 THEN max_abs = -max_abs
snr = max_abs / stddev_amp

PRINT, '  Seismic Data Statistics:'
PRINT, '    Mean amplitude: ', mean_amp
PRINT, '    Std deviation: ', stddev_amp
PRINT, '    Signal-to-noise ratio: ', snr
PRINT, '    RMS amplitude: ', rms_amp
PRINT, ''

; Frequency content (simplified)
PRINT, '  Estimated Frequency Content:'
PRINT, '    Dominant period: ~12ms (based on wavelet width)'
PRINT, '    Dominant frequency: ~80 Hz'
PRINT, '    Vertical resolution: ~15-20m (lambda/4)'
PRINT, ''

; ================================================================
; Summary
; ================================================================
PRINT, '=================================================='
PRINT, 'Geophysical Workflow Complete!'
PRINT, '=================================================='
PRINT, ''
PRINT, 'Demonstrated:'
PRINT, '  - Synthetic 3D seismic cube generation'
PRINT, '  - Geological layer modeling with structure'
PRINT, '  - Anticline (dome) feature creation'
PRINT, '  - Normal fault with vertical offset'
PRINT, '  - Inline and crossline section extraction'
PRINT, '  - Time slice (horizon) visualization'
PRINT, '  - Seismic attribute computation'
PRINT, '  - Automated fault detection'
PRINT, '  - Horizon auto-picking and tracking'
PRINT, '  - Structural interpretation'
PRINT, ''
PRINT, 'Key Features Identified:'
PRINT, '  • Anticline closure area: ', closure_area, ' km²'
PRINT, '  • Structural relief: ', mean_depth - horizon_min, ' ms'
PRINT, '  • Normal fault with ~20ms throw'
PRINT, '  • Reservoir reflection amplitude: ', reservoir_amp
PRINT, ''
PRINT, 'Next Steps:'
PRINT, '  - Import real SEG-Y seismic data'
PRINT, '  - Add migration and processing workflows'
PRINT, '  - Implement advanced attribute analysis'
PRINT, '  - Add well log correlation'
PRINT, '  - Perform reservoir characterization'
PRINT, ''

; ================================================================
; STEP 13: 3D Volume Visualization (Optional)
; ================================================================
PRINT, '> Step 13: Launching 3D visualization...'
PRINT, ''

; Initialize VIZ3D
VIZ3D_INIT, WINDOW_SIZE=[1280, 720], TITLE='Geophysical Data - Seismic Cube'

; Set colormap for seismic data (rainbow shows amplitude variations well)
VIZ3D_COLORMAP, 'RAINBOW'

; Set camera position to view the cube
cam_dist = 2.5
VIZ3D_CAMERA, POSITION=[cam_dist, cam_dist, cam_dist], TARGET=[0.0, 0.0, 0.0], FOV=45.0

; Load seismic volume
VIZ3D_VOLUME, seismic, DIMENSIONS=[nx, ny, nz]

PRINT, '  Volume loaded: ', nx, ' x ', ny, ' x ', nz
PRINT, '  Amplitude range: [', seismic_min, ', ', seismic_max, ']'
PRINT, ''
PRINT, '  Rendering 3D seismic cube...'
PRINT, '  - Blue/negative: Troughs (possible hydrocarbon indicators)'
PRINT, '  - Red/positive: Peaks (strong reflections)'
PRINT, '  - Structures: Anticline and fault visible in volume'
PRINT, ''

; Render the volume
VIZ3D_RENDER, /INTERACTIVE, TITLE='Seismic Amplitude Cube - Interactive 3D View'

PRINT, ''
PRINT, '✓ 3D visualization complete!'
PRINT, ''
PRINT, '=================================================='
PRINT, 'All Workflow Steps Complete!'
PRINT, '=================================================='
PRINT, ''
