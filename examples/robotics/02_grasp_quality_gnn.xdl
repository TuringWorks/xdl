; ============================================
; Grasp Quality Prediction with Graph Neural Network
; ============================================
; Implements a simplified GNN for predicting grasp quality
; based on contact points and object geometry
;
; Run with: cargo run -- examples/robotics/02_grasp_quality_gnn.xdl

print, "======================================================"
print, "    GRASP QUALITY PREDICTION - GNN MODEL"
print, "======================================================"
print, ""

; --------------------------------------
; Object Point Cloud Representation
; --------------------------------------
print, "Loading object point cloud..."

; Simulate a simple box object (8 corner points)
num_points = 8
point_x = [-0.05, 0.05, 0.05, -0.05, -0.05, 0.05, 0.05, -0.05]
point_y = [-0.03, -0.03, 0.03, 0.03, -0.03, -0.03, 0.03, 0.03]
point_z = [0.0, 0.0, 0.0, 0.0, 0.1, 0.1, 0.1, 0.1]

; Surface normals at each point
normal_x = [-1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0]
normal_y = [-1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0]
normal_z = [-1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0]

; Normalize normals
for i = 0, num_points - 1
    mag = sqrt(normal_x[i]^2 + normal_y[i]^2 + normal_z[i]^2)
    normal_x[i] = normal_x[i] / mag
    normal_y[i] = normal_y[i] / mag
    normal_z[i] = normal_z[i] / mag
endfor

print, "Object: Box with", num_points, "vertices"
print, "Dimensions: 10cm x 6cm x 10cm"
print, ""

; --------------------------------------
; Graph Construction
; --------------------------------------
print, "Building contact graph..."

; Adjacency matrix (k-nearest neighbors, k=3)
k_neighbors = 3
adj_matrix = fltarr(num_points * num_points)

; Compute pairwise distances
for i = 0, num_points - 1
    for j = 0, num_points - 1
        dx = point_x[i] - point_x[j]
        dy = point_y[i] - point_y[j]
        dz = point_z[i] - point_z[j]
        dist = sqrt(dx*dx + dy*dy + dz*dz)
        ; Store distance (will be converted to adjacency)
        adj_matrix[i * num_points + j] = dist
    endfor
endfor

print, "Graph constructed with", num_points, "nodes"
print, "Edge connectivity: k-NN with k=", k_neighbors
print, ""

; --------------------------------------
; GNN Node Features
; --------------------------------------
print, "Computing node features..."

; Feature vector for each node: [x, y, z, nx, ny, nz, curvature]
feature_dim = 7
node_features = fltarr(num_points * feature_dim)

for i = 0, num_points - 1
    base_idx = i * feature_dim
    node_features[base_idx + 0] = point_x[i]
    node_features[base_idx + 1] = point_y[i]
    node_features[base_idx + 2] = point_z[i]
    node_features[base_idx + 3] = normal_x[i]
    node_features[base_idx + 4] = normal_y[i]
    node_features[base_idx + 5] = normal_z[i]
    ; Estimate curvature (simplified)
    node_features[base_idx + 6] = 0.1  ; Constant for box corners
endfor

print, "Node feature dimension:", feature_dim
print, ""

; --------------------------------------
; Grasp Configuration
; --------------------------------------
print, "Defining grasp configuration..."

; Two-finger parallel jaw gripper
; Contact point 1 (left finger)
contact1_x = -0.05
contact1_y = 0.0
contact1_z = 0.05

; Contact point 2 (right finger)
contact2_x = 0.05
contact2_y = 0.0
contact2_z = 0.05

; Approach direction
approach_x = 0.0
approach_y = 0.0
approach_z = -1.0

print, "Gripper: Parallel jaw (2 fingers)"
print, "Contact 1: (", contact1_x, ",", contact1_y, ",", contact1_z, ")"
print, "Contact 2: (", contact2_x, ",", contact2_y, ",", contact2_z, ")"
print, "Approach: (", approach_x, ",", approach_y, ",", approach_z, ")"
print, ""

; --------------------------------------
; GNN Message Passing (Simplified)
; --------------------------------------
print, "Running GNN forward pass..."

; Layer 1: Message passing
hidden_dim = 16
layer1_output = fltarr(num_points * hidden_dim)

; Simplified message aggregation (mean of neighbor features)
for i = 0, num_points - 1
    for h = 0, hidden_dim - 1
        sum_msg = 0.0
        count = 0
        for j = 0, num_points - 1
            dist = adj_matrix[i * num_points + j]
            ; Include if within threshold (neighbors)
            is_neighbor = dist gt 0.001 and dist lt 0.15
            weight = is_neighbor ? 1.0 / (dist + 0.01) : 0.0
            ; Aggregate features with learned weights (simulated)
            feat_idx = (h mod feature_dim)
            sum_msg = sum_msg + weight * node_features[j * feature_dim + feat_idx]
            count = count + (is_neighbor ? 1 : 0)
        endfor
        ; Apply ReLU activation
        layer1_output[i * hidden_dim + h] = sum_msg > 0 ? sum_msg : 0.0
    endfor
endfor

print, "  Layer 1: Message passing complete"
print, "  Hidden dimension:", hidden_dim

; Layer 2: Global pooling
global_features = fltarr(hidden_dim)
for h = 0, hidden_dim - 1
    sum_val = 0.0
    for i = 0, num_points - 1
        sum_val = sum_val + layer1_output[i * hidden_dim + h]
    endfor
    global_features[h] = sum_val / num_points
endfor

print, "  Layer 2: Global pooling complete"

; --------------------------------------
; Grasp Quality Metrics
; --------------------------------------
print, ""
print, "Computing grasp quality metrics..."

; 1. Force Closure Analysis
; Contact normals should oppose each other
n1_x = -1.0  ; Left contact normal (pointing right)
n1_y = 0.0
n1_z = 0.0

n2_x = 1.0   ; Right contact normal (pointing left)
n2_y = 0.0
n2_z = 0.0

; Force closure requires opposing normals
dot_normals = n1_x * n2_x + n1_y * n2_y + n1_z * n2_z
force_closure = dot_normals lt -0.5 ? 1 : 0

print, "  Force closure:", force_closure, "(", dot_normals, ")"

; 2. Grasp Wrench Space Analysis (Simplified)
; Compute grasp matrix G
contact_dist = sqrt((contact2_x - contact1_x)^2 + (contact2_y - contact1_y)^2 + (contact2_z - contact1_z)^2)
print, "  Contact distance:", contact_dist * 1000, "mm"

; 3. Ferrari-Canny metric (largest ball in wrench space)
; Simplified estimation
grasp_width = contact_dist
ferrari_canny = 1.0 / (1.0 + exp(-10.0 * (grasp_width - 0.05)))

print, "  Ferrari-Canny metric:", ferrari_canny

; 4. Antipodal score
; Perfect antipodal grasp has opposing contact normals
antipodal_score = abs(dot_normals)
print, "  Antipodal score:", antipodal_score

; --------------------------------------
; GNN Prediction Output
; --------------------------------------
print, ""
print, "======================================================"
print, "    GNN GRASP QUALITY PREDICTION"
print, "======================================================"

; Combine metrics with learned weights (simulated)
w1 = 0.3  ; Force closure weight
w2 = 0.4  ; Ferrari-Canny weight
w3 = 0.3  ; Antipodal weight

quality_score = w1 * force_closure + w2 * ferrari_canny + w3 * antipodal_score

print, ""
print, "Grasp Quality Score:", quality_score
print, ""

; Classification
print, "Classification:"
classification = quality_score gt 0.7 ? "GOOD GRASP" : (quality_score gt 0.4 ? "MARGINAL GRASP" : "POOR GRASP")
print, "  Result:", classification
print, ""

; Confidence breakdown
print, "Quality Breakdown:"
print, "  Force Closure:    ", force_closure * 100, "%"
print, "  Stability:        ", ferrari_canny * 100, "%"
print, "  Antipodal:        ", antipodal_score * 100, "%"

print, ""
print, "======================================================"
print, "    GRASP QUALITY ANALYSIS COMPLETE"
print, "======================================================"
